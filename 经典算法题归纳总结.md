

# 刷题重点

- 二叉树 + 链表
- 二分 + 双指针
- 回溯 + 递归
- 动态规划

[剑指offer](https://www.nowcoder.com/ta/coding-interviews)，[labuladuo算法小抄](https://labuladong.gitbook.io/algo/)

labuladong：

- [笔试突击](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=100007475&idx=1&sn=2456bf9d61d65638decb534820c55a33&chksm=1bd7e03b2ca0692dfd4245c938a421ae552167264dc51820b59ff41e67c54e0347df33cc2947&mpshare=1&scene=23&srcid=0614Uqf6q0DR4yXWpEGIX14X&sharer_sharetime=1623663284245&sharer_shareid=eb8cd503b0c8cf290ef96009ab610ac7#rd)
- [查漏补缺](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=100007461&idx=1&sn=e1d76a2636734184f73e12e938d20901&chksm=1bd7e02d2ca0693bca42dcd92394534b321215699e0c7d512150bbc4e72e58d0d6271e11593a&mpshare=1&scene=23&srcid=0614cszZARXy0SEDu3gJm9KQ&sharer_sharetime=1623664268745&sharer_shareid=eb8cd503b0c8cf290ef96009ab610ac7#rd)



# 做题分析

[我的力扣做题分析](https://leetcode-cn.com/progress/)

# 经典题目归纳总结

### 1.数组

#### 二分查找代码模板

```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0;
        int right = n; // 我们定义target在左闭右开的区间里，[left, right)  
        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间
            int middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle; // target 在左区间，因为是左闭右开的区间，nums[middle]一定不是我们的目标值，所以right = middle，在[left, middle)中继续寻找目标值
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，在 [middle+1, right)中
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值的情况，直接返回下标
            }
        } 
        return right;
    }
};

```



- 二分法

  [第35题：搜索插入位](https://leetcode-cn.com/problems/search-insert-position/)

- 双指针法

  [第27题： 移除元素](https://leetcode-cn.com/problems/remove-element/)

- 滑动窗口

  [第209题：长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/ )

- 模拟行为

  [第59题：螺旋矩阵II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

### 2.链表

#### 定义链表结构（c++）

```c++
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};
```



- 虚拟头节点

  [题目203：移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

- 链表常见的5个操作

  [第707题：设计链表](https://leetcode-cn.com/problems/design-linked-list/)

- 双指针翻转列表，也可递归

  [第206题：翻转单列表](https://leetcode-cn.com/problems/reverse-linked-list/)

- 快慢指针，找环，找入口

  [第142题：环形链表Ⅱ](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

### 3.哈希表

- 数组就是简单的哈希，数组的大小是受限的

  [第242题：有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

- 哈希值太大，还是用set

  [第349题. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

- 用set判断快乐数

  [第202题. 快乐数](https://leetcode-cn.com/problems/happy-number/)

- map记录两个值

  [第一题：两数之和](https://leetcode-cn.com/problems/two-sum/)

- 巧用map，先解决两个数

  [第454题.四数相加II](https://leetcode-cn.com/problems/4sum-ii/)

- 利用数组解决，与字母异位词类似
  
  [第383题. 赎金信](https://leetcode-cn.com/problems/ransom-note/)

- 双指针更合适，注意去重操作
  [第15题. 三数之和](https://leetcode-cn.com/problems/3sum/)

- 与上题思路相同，双指针法

  [第18题. 四数之和](https://leetcode-cn.com/problems/4sum/)

### 4.字符串

- 简单地翻转，不能使用reverse

  [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

- 可使用reverse库函数

  [第541题. 反转字符串II](https://leetcode-cn.com/problems/reverse-string-ii/)

- 先给数组扩容，再从后向前操作（双指针法）

  [剑指Offer 05.替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

- 双指针，实现库函数

  [第151题：翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

- 局部反转+整体反转

  [剑指Offer58-II.左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

#### KMP 构建前缀表c++代码

```c++
void getNext (int* next, const string& s) {
    int j = -1; // 前缀表统一减一版本
    next[0] = -1;
    for (int i = 1; i < s.size(); i++) {
        while (j >= 0 && s[i] != s[j + 1]) {
            j = next[j];
        }
        if (s[i] == s[j + 1]) {
            j++;
        }
        next[i] = j;
    }
}
```

```c++
void getNext (int* next, const string& s) {
    int j = 0; // 前缀表不减一版本
    next[0] = 0;
    for (int i = 1; i < s.size(); i++) {
        while (j > 0 && s[i] != s[j]) {
            j = next[j - 1];
        }
        if (s[i] == s[j]) {
            j++;
        }
        next[i] = j;
    }
}
```



- KMP算法，构建next数组

  [实现strStr()](https://leetcode-cn.com/problems/implement-strstr/)

- 巧用KMP判断重复字符串

  [第459题.重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/submissions/)

### 5.双指针法

前面数组中已经涉及到

### 6.栈与队列

- 用队列实现栈

  [第225题.用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

- 用栈解决对称匹配

  [第20题.有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

- 把字符串导入栈中

  [第1047题. 删除字符串中的所有相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)

- 用栈解决

  [第150题. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

- 手动实现单调队列解决滑动窗口问题

  [第239题. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

- 优先级队列与堆

  [第347题.前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

### 7.二叉树

####    分类

- **满二叉树**：只有度为0的结点和度为2的结点，并且度为0的结点在同一层上（深度为k，有2^k-1个节点）；
- **完全二叉树**：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置；
- **二叉搜索树：**
  - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
  - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
  - 它的左、右子树也分别为二叉排序树；
- **平衡二叉树：**一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树；

####    存储方式

- 链式存储（指针）
- 顺序存储（数组）[**如果父节点的数组下表是i，那么它的左孩子就是i * 2 + 1，右孩子就是 i * 2 + 2。**]

####    遍历方式

- 深度优先遍历(DFS)
  - 前序遍历（中左右）
  - 中序遍历（左中右）
  - 后序遍历（左右中）
- 广度优先遍历
  - 层次遍历

####    二叉树定义c++代码

链式存储：

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

#### (DFS)深度优先遍历（递归）代码模板

**前序遍历（中左右）**

```c++
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    vec.push_back(cur->val);    // 中 ，同时也是处理节点逻辑的地方
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
}
```

**中序遍历（左中右）**

```c++
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 中 ，同时也是处理节点逻辑的地方
    traversal(cur->right, vec); // 右
}
```

**后序遍历（左右中）**

```c++
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
    vec.push_back(cur->val);    // 中 ，同时也是处理节点逻辑的地方
}
```

#### (DFS)深度优先遍历（迭代用栈）代码模板

**前序遍历（中左右）**

```c++
vector<int> preorderTraversal(TreeNode* root) {
    vector<int> result;
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        st.pop();
        if (node != NULL) {
            if (node->right) st.push(node->right);  // 右
            if (node->left) st.push(node->left);    // 左
            st.push(node);                          // 中
            st.push(NULL);                          
        } else {
            node = st.top();
            st.pop();
            result.push_back(node->val);            // 节点处理逻辑
        }
    }
    return result;
}
```

**中序遍历（左中右）**

```c++
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> result;
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
            if (node->right) st.push(node->right);  // 添加右节点（空节点不入栈）

            st.push(node);                          // 添加中节点
            st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。

            if (node->left) st.push(node->left);    // 添加左节点（空节点不入栈）
        } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
            st.pop();           // 将空节点弹出
            node = st.top();    // 重新取出栈中元素
            st.pop();
            result.push_back(node->val); // 加入到结果集
          }
        }
        return result;
}
```

**后序遍历（左右中）**

```c++
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> result;
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop();
            st.push(node);                          // 中
            st.push(NULL);
            if (node->right) st.push(node->right);  // 右
            if (node->left) st.push(node->left);    // 左

        } else {
            st.pop();
            node = st.top();
            st.pop();
            result.push_back(node->val);            // 节点处理逻辑
        }
    }
    return result;
}
```

#### (BFS)广度优先遍历（迭代用队列）代码模板

```c++
vector<vector<int>> levelOrder(TreeNode* root) {
    queue<TreeNode*> que;
    if (root != NULL) que.push(root);
    vector<vector<int>> result;
    while (!que.empty()) {
        int size = que.size();
        vector<int> vec;
        for (int i = 0; i < size; i++) {// 这里一定要使用固定大小size，不要使用que.size()
            TreeNode* node = que.front();
            que.pop();
            vec.push_back(node->val);   // 节点处理的逻辑
            if (node->left) que.push(node->left);
            if (node->right) que.push(node->right);
        }
        result.push_back(vec);
    }
    return result;
}
```

- 广度优先遍历

  [第102题.二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/submissions/)

- 自底向上的层次遍历，最后加一个翻转就可

  [107.二叉树的层次遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

- 判断是否遍历到单层最后一个元素，是就放进res中

  [第199题.二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

- 求平均值

  [第637题.二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

- N叉树层级遍历

  [第429题.N叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

#### 二叉树的属性

- 递归或者迭代

  [第101题. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

- 二叉树最大深度，迭代模板题

  [第104题.二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

- N叉树最大深度，迭代模板题

  [第559题.N叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/submissions/)

- 二叉树的最小深度

  [第111题.二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/submissions/)

- 二叉树节点数量，套模板

  [第222题.完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

- 平不平衡看高度，递归效率更高

  [第110题.平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/submissions/)

- 求路径，递归体现回溯，也可迭代

  [第257题. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

- 通过该节点的父节点判断该节点的属性

  [第404题.左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

- 广度优先搜索迭代简单

  [第513题.找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

- 回溯递归，深度优先搜索，搜索一条符合要求的路径即可

  [第112题. 路径总和](https://leetcode-cn.com/problems/path-sum/submissions/)

- 回溯递归，深度优先搜索，搜索所有路径，找出所有符合的路径

  [第113题. 路径总和II](https://leetcode-cn.com/problems/path-sum-ii/)

- 寻找重复的子树, 用map + 递归

  [第652题.寻找重复的字数](https://leetcode-cn.com/problems/find-duplicate-subtrees/)

#### 二叉树的修改与构造

- 翻转二叉树（[第226题.翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)）
  - 递归：前序，交换左右孩子
  - 迭代：直接模拟前序遍历
  
- 构造二叉（前序和后序不能确定唯一一颗二叉树，前序和中序遍历可以，同样后序和中序也可以）

  ​			[第106题.从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/submissions/)

  ​			[第105题. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/submissions/)

  - 递归：前序，重点在于找分割点，分左右区间构造
  - 迭代：比较复杂，意义不大

- 构造最大二叉树

  ​			[第654题.最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/submissions/)

  - 递归：前序，分割点为数组最大值，分左右区间构造
  - 迭代：比较复杂，意义不大

- 合并两个二叉树

  ​			[第617题.合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/submissions/)

  - 递归：前序，同时操作两个树的节点，注意合并的规则
  - 迭代：使用队列，类似层序遍历

- 连接相邻的两个节点

  ​			[第116题.填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

  - 递归：定义两个节点node1，node2

- 将二叉树展开为链表

  ​			[第114题.二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

  - 递归：后序

#### 二叉搜索树（BTS）的属性

- 二叉搜索树中的搜索

  ​			[第700题.二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/submissions/)

  - 递归：二叉搜索树的递归是有方向的
  - 迭代：因为有方向，所以迭代法很简单

- 是不是二叉搜索树

  ​			[第98题.验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/submissions/)

  - 递归：中序，相当于变成了判断一个序列是不是递增的
  - 迭代：模拟中序，逻辑相同

- 求二叉搜索树的最小绝对差

  ​			[第530题.二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/submissions/)

  - 递归：中序，双指针操作
  - 迭代：模拟中序，逻辑相同

- 求二叉搜索树的众数

  ​			[第501题.二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/submissions/)

  - 递归：中序，清空结果集的技巧，遍历一遍便可求众数集合
  - 迭代：模拟中序，逻辑相同

- 二叉搜索树转成累加树

  ​			[第538题.把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/submissions/)

  - 递归：中序，双指针操作累加
  - 迭代：模拟中序，逻辑相同

#### 二叉搜索树的修改与构造

- 二叉搜索树中的插入操作
  
  ​			[第701题.二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/submissions/)
  
  - 递归：顺序无所谓，通过递归函数返回值添加节点
  - 迭代：按序遍历，需要记录插入父节点，这样才能做插入操作
  
- 二叉搜索树中的删除操作
  
  ​			[第450题.删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)
  
  - 递归：前序，想清楚删除非叶子节点的情况
  - 迭代：有序遍历，较复杂
  
- 修剪二叉搜索树
  
  ​			[第669题. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)
  
  - 递归：前序，通过递归函数返回值删除节点
  - 迭代：有序遍历，较复杂
  
- 构造二叉搜索树
  
  ​			[第108题.将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)
  
  - 递归：前序，数组中间节点分割
  - 迭代：较复杂，通过三个队列来模拟

#### 二叉树公共祖先问题

- 递归回溯

  [第236题. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

- 利用好搜索树的大小顺序，简单的迭代或递归

  [第235题. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/submissions/)

#### 二叉树深度代码

```c++
int getDepth(TreeNode* node) {
    if (node == NULL) return 0;
    return 1 + max(getDepth(node->left), getDepth(node->right));
}
```

#### 二叉树节点数量代码

```c++
int countNodes(TreeNode* root) {
    if (root == NULL) return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
}
```

### 8.动态规划

#### 基础

动规的五部曲：

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

[第509题. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/submissions/)

[第70题. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/submissions/)

[第746题. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/submissions/)

[第64题.最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

#### 背包问题

###### 01背包系列

```c++
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { 
        // 遍历背包容量,从大到小遍历,保证每个物品只被添加一次
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

[0-1背包](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.md)

[416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

[1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)

[494. 目标和](https://leetcode-cn.com/problems/target-sum/)

[474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

###### 完全背包系列

```c++
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j < bagWeight ; j++) { 
        // 遍历背包容量,从小到大遍历,保证每个物品可被多次添加
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

[518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)  (求兑出金额的组合数)

```c++
for (int i = 0; i < coins.size(); i++) { // 遍历物品
    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
        dp[j] += dp[j - coins[i]];
    }
} //注意，求组合数一定是先遍历物品再遍历背包容量
```

[377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)  (完全背包**求排列数目，先遍历背包容量再遍历物品**)

```c++
for (int i = 0; i <= target; i++) { // 遍历背包
    for (int j = 0; j < nums.size(); j++) { // 遍历物品
        if (i - nums[j] >= 0 && dp[i] < INT_MAX - dp[i - nums[j]]) {
            dp[i] += dp[i - nums[j]];
        }
    }
}
```

[139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

#### 股票问题

[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

[123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

[188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

[309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

[714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

#### 打家劫舍问题

[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

[213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

[337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

#### 子序列问题

###### 子序列-不连续

[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

[1035. 不相交的线](https://leetcode-cn.com/problems/uncrossed-lines/)

###### 连续子数组

[674. 最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)

[53.最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

[718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

###### 编辑距离

[392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

[115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

[583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

[73.编辑距离](https://leetcode-cn.com/problems/edit-distance/)

###### 回文

[647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

[516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

### 9.回溯算法

[39.组合总和](https://leetcode-cn.com/problems/combination-sum/)

[40.组合总和Ⅱ](https://leetcode-cn.com/problems/combination-sum-ii/)

[面试题 08.08. 有重复字符串的排列组合](https://leetcode-cn.com/problems/permutation-ii-lcci/)

[46.全排列](https://leetcode-cn.com/problems/permutations/)

[47.全排列Ⅱ](https://leetcode-cn.com/problems/permutations-ii/)

[78.子集](https://leetcode-cn.com/problems/subsets/)

[90.子集Ⅱ](https://leetcode-cn.com/problems/subsets-ii/)

[679.24点游戏](https://leetcode-cn.com/problems/24-game/)

####     代码模板

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

# 高级数据结构

### 10.优先队列

##### 		本质

二叉堆的结构，堆在英文里叫Binary Heap，利用一个**数组**结构来实现完全二叉树；

##### 		特性

数组里的第一个元素array[0]拥有最高的优先级，给定一个下标i，那么对于元素array[i]而言：

- **父节点**对应的元素下标是（i - 1）/ 2
- **左侧子节点**对应的下标是2*i + 1
- **右侧子节点**对应的下标是2*i + 2

数组中每个元素的优先级都必须高于它两侧的子节点

##### 		基本操作

- 向上筛选
- 向下筛选

**时间复杂度**：O(logk) (k为树的深度)

**初始化**一个大小为n的优先队列（堆）**时间复杂度**为O(n)

典型例题：[力扣第347题：前k个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

##### 定义问题：

```c++
priority_queue <int> heap;//默认是大根堆，即heap.top()是最大的
priority_queue <int, vector<int>, less <int> > heap; //大根堆
priority_queue <int, vector<int>, greater <int> > heap; //小根堆
//重写比较函数
class mycomparison {
    public:
        bool operator() (const pair<int, int>& lhs, const pair<int, int>& rhs){
            return lhs.second > rhs.second; //实现小根堆
        }
    };
priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> heap;//小根堆
```



### 11.图

### 12.前缀树

### 13.线段树

### 14.树状数组